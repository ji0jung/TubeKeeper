# Unit3 Card Creation & Management - 도메인 모델 설계 계획

## 개요
Unit3는 유튜브 링크를 기반으로 카드를 생성하고 편집하는 기능을 담당하는 독립적인 단위입니다. 도메인 주도 설계(DDD)를 사용하여 전술적 구성 요소들을 설계합니다.

## 설계 단계별 계획

### 1단계: 도메인 분석 및 핵심 개념 식별
- [x] 1.1 사용자 스토리 분석 및 도메인 개념 추출
- [x] 1.2 핵심 비즈니스 규칙 및 제약사항 식별
- [x] 1.3 도메인 전문가 언어(Ubiquitous Language) 정의
- [x] 1.4 바운디드 컨텍스트 경계 확인

### 2단계: 애그리게이트 설계
- [x] 2.1 애그리게이트 루트 식별 (Card)
- [x] 2.2 애그리게이트 경계 정의
- [x] 2.3 애그리게이트 불변성 규칙 정의
- [x] 2.4 애그리게이트 간 참조 관계 설계

### 3단계: 엔티티 및 값 객체 설계
- [x] 3.1 Card 엔티티 설계
- [x] 3.2 값 객체 식별 및 설계
  - [x] YouTubeUrl 값 객체
  - [x] VideoMetadata 값 객체
  - [x] Thumbnail 값 객체
  - [x] Script 값 객체
  - [x] Summary 값 객체
  - [x] Tags 값 객체
  - [x] Memo 값 객체
- [x] 3.3 엔티티와 값 객체 간 관계 정의

### 4단계: 도메인 서비스 설계
- [x] 4.1 YouTube 메타데이터 추출 서비스
- [x] 4.2 AI 요약 생성 서비스
- [x] 4.3 카드 중복 검증 서비스
- [x] 4.4 썸네일 처리 서비스

### 5단계: 도메인 이벤트 설계
- [x] 5.1 카드 생성 관련 이벤트
- [x] 5.2 메타데이터 수집 관련 이벤트
- [x] 5.3 AI 요약 생성 관련 이벤트
- [x] 5.4 카드 수정/삭제 관련 이벤트

### 6단계: 정책(Policy) 설계
- [x] 6.1 카드 생성 정책
- [x] 6.2 메타데이터 수집 정책
- [x] 6.3 AI 요약 생성 정책
- [x] 6.4 오류 처리 정책

### 7단계: 리포지토리 인터페이스 설계
- [x] 7.1 CardRepository 인터페이스 정의
- [x] 7.2 PostgreSQL 데이터 모델 설계 (Unit1, 2와 일관성 유지)
- [x] 7.3 쿼리 패턴 정의 및 인덱스 설계

### 8단계: 외부 서비스 인터페이스 설계
- [x] 8.1 YouTube API 인터페이스
- [x] 8.2 AI 서비스 인터페이스
- [x] 8.3 카테고리 서비스 인터페이스 (Unit2와의 통합)

### 9단계: 오류 코드 및 예외 처리 설계
- [x] 9.1 도메인 예외 클래스 설계
- [x] 9.2 오류 코드 정의 및 integration_contract.md 업데이트
- [x] 9.3 예외 처리 전략 수립

### 10단계: 문서화 및 검토
- [x] 10.1 domain_model.md 파일 작성
- [x] 10.2 다른 Unit과의 일관성 검토
- [x] 10.3 설계 검증 및 최종 검토

## 설계 시 고려사항

### 비즈니스 규칙
[Question] 하나의 유튜브 URL로 여러 개의 카드를 생성할 수 있나요? 아니면 중복 방지가 필요한가요?
[Answer] 중복 방지 필요. 동일한 YouTube URL로는 하나의 카드만 생성 가능. 기존 카드 존재 시 적절한 메시지 표시.

[Question] 카드 생성 시 카테고리 지정이 필수인가요? 기본 카테고리가 있나요?
[Answer] 카테고리 지정 필수. 기본값은 사용자가 이전에 카드 생성 시 마지막으로 선택한 카테고리가 화면에 미리 선택된 상태로 표시. 사용자가 변경하면 변경된 카테고리로 지정됨. 

[Question] AI 요약 생성이 실패했을 때 카드 생성 자체를 실패로 처리해야 하나요? 아니면 요약 없이 카드를 생성해야 하나요?
[Answer] 우선 재시도를 하도록 하고, 2번 실패한 경우 우선 카드 생성하고 생성된 카드에서 추후에 다시 요약 요청할 수 있어야 함.

[Question] 유튜브 메타데이터 수집이 실패했을 때의 처리 방식은 어떻게 해야 하나요?
[Answer] URL이 잘못된 경우 URL에 문제 있다고 하고, YouTube 자체가 이상한 경우 YouTube 서버가 불안정하다고 하고, 우리 서버 문제일 경우 재시도를 한번 하고 안되면 서버가 장애있다고 조금 이따 다시 시도해 달라고 하면서 생성 중인 카드 상태로 만들어서 사용자가 인지 가능하도록 표시해야 함. 적절히 상황에 맞게 사용자에게 대응해야 함. 

### 기술적 제약사항
[Question] 유튜브 스크립트(자막) 수집 시 언어 제한이 있나요? 한국어만 지원하나요?
[Answer] 언어 제한 없음. 모든 언어의 스크립트를 한국어 또는 영어로 요약 생성 가능.

[Question] AI 요약 생성 시 스크립트 길이 제한이 있나요?
[Answer] 최대 100,000자까지 처리 가능. 초과 시 "동영상이 너무 길어 요약할 수 없습니다" 메시지 표시. 출력은 3-5줄로 제한 (최대 200 토큰).

[Question] 썸네일 이미지는 어디에 저장하나요? (S3, 외부 URL 참조 등)
[Answer] S3에 썸네일 이미지 저장 + YouTube URL 직접 참조 둘 다 구현. 환경변수 THUMBNAIL_SOURCE 값에 따라 동적 선택 (S3 또는 YOUTUBE). 카드 생성 시 항상 S3에 백업 저장.

### 성능 및 확장성
[Question] 카드 생성 시 YouTube API 호출과 AI 요약 생성을 동기적으로 처리해야 하나요? 아니면 비동기 처리가 가능한가요?
[Answer] YouTube API 호출은 동기로 처리하고, AI 요약 생성은 비동기로 처리. 카드는 우선 생성하고 요약이 완료되지 않은 상태에서는 카드에 "요약 생성중"으로 표시. 

## 참고 자료
- Unit1 Authentication 도메인 모델: `/aidlc-docs/construction/unit1_authentication/domain_model.md`
- Unit2 Category Management 도메인 모델: `/aidlc-docs/construction/unit2_category_management/domain_model.md`
- Integration Contract: `/aidlc-docs/inception/units/integration_contract.md`
- Unit3 요구사항: `/aidlc-docs/inception/units/unit3_card_creation.md`

## 완료 기준
- 모든 전술적 DDD 구성 요소가 정의됨
- 비즈니스 규칙과 제약사항이 도메인 모델에 반영됨
- 다른 Unit과의 통합 지점이 명확히 정의됨
- PostgreSQL 데이터 모델이 설계됨 (Unit1, 2와 일관성 유지)
- 필요한 오류 코드가 integration_contract.md에 추가됨

---

# Unit3 Card Creation & Management - 논리적 설계 계획

## 개요
도메인 모델을 기반으로 소프트웨어 소스 코드 구현을 위한 논리적 설계를 생성합니다. 확장성이 높은 이벤트 기반 시스템의 논리적 아키텍처를 설계합니다.

## 논리적 설계 단계별 계획

### 1단계: 아키텍처 레이어 설계
- [x] 1.1 헥사고날 아키텍처 레이어 정의
  - [x] Domain Layer (도메인 모델, 서비스, 이벤트)
  - [x] Application Layer (유스케이스, 커맨드/쿼리 핸들러)
  - [x] Infrastructure Layer (리포지토리 구현, 외부 서비스)
  - [x] Presentation Layer (API 컨트롤러, DTO)
- [x] 1.2 의존성 방향 및 인터페이스 정의
- [x] 1.3 패키지 구조 설계

### 2단계: Application Layer 설계
- [x] 2.1 유스케이스 식별 및 설계
  - [x] CreateCardUseCase
  - [x] GetCardUseCase
  - [x] UpdateCardUseCase
  - [x] DeleteCardUseCase
  - [x] GetCardsByUserUseCase
  - [x] GetCardsByCategoryUseCase
  - [x] ToggleFavoriteUseCase (즐겨찾기 기능)
- [x] 2.2 Command/Query 객체 설계
- [x] 2.3 Application Service 설계
- [x] 2.4 DTO (Data Transfer Object) 설계

[Question] 카드 생성 시 YouTube 메타데이터 수집과 AI 요약 생성의 비동기 처리를 위해 어떤 메시지 큐 시스템을 사용하시겠습니까? (예: AWS SQS, Redis, RabbitMQ 등)
[Answer] 혼합 사용: YouTube 메타데이터 수집은 Redis Pub/Sub, AI 요약 생성은 AWS SQS 사용

**결정 이유:**
- **Redis Pub/Sub (메타데이터 수집)**: 실시간성이 중요하고, 실패 시 재시도가 용이하며, 빠른 응답이 필요
- **AWS SQS (AI 요약 생성)**: 처리 시간이 길고 비용이 높아 안정성이 중요하며, DLQ를 통한 실패 처리 필요

[Question] 이벤트 소싱 패턴을 적용하시겠습니까? 아니면 단순한 이벤트 발행만 하시겠습니까?
[Answer] 단순한 이벤트 발행만 적용

**결정 이유:**
- 카드 생성/수정 빈도가 높지 않아 이벤트 소싱의 복잡성 대비 이점이 적음
- 현재 요구사항에서는 상태 변경 히스토리 추적이 필수가 아님
- 구현 복잡도를 낮춰 개발 속도 향상

**이벤트 소싱이 불필요한 이유:**
- 법적 규제 요구사항 없음 (강력한 감사 추적 불필요)
- 복잡한 비즈니스 분석 요구사항 없음
- 시간 기반 쿼리 요구사항 없음 (과거 특정 시점 상태 조회 불필요)
- 카드 생성/수정 빈도가 낮아 높은 동시성 처리 불필요
- 단순한 도메인 로직으로 이벤트 소싱의 복잡성이 과도함

### 3단계: Infrastructure Layer 설계
- [x] 3.1 리포지토리 구현 설계
  - [x] PostgreSQLCardRepository
  - [x] 쿼리 최적화 및 인덱스 활용
- [x] 3.2 외부 서비스 어댑터 설계
  - [x] YouTubeApiAdapter
  - [x] BedrockAiSummaryAdapter
  - [x] S3ThumbnailStorageAdapter
- [x] 3.3 이벤트 발행 인프라 설계
  - [x] EventPublisher 구현
  - [x] 메시지 큐 연동
- [x] 3.4 설정 관리 및 환경 변수 설계

### 4단계: Presentation Layer 설계
- [x] 4.1 REST API 컨트롤러 설계
  - [x] CardController
  - [x] 요청/응답 DTO 매핑
- [x] 4.2 API 문서화 (OpenAPI/Swagger)
- [x] 4.3 인증/인가 미들웨어 통합
- [x] 4.4 오류 처리 및 응답 표준화

### 5단계: 이벤트 기반 아키텍처 설계
- [x] 5.1 도메인 이벤트 발행 메커니즘
- [x] 5.2 이벤트 핸들러 설계
  - [x] MetadataCollectionEventHandler
  - [x] AiSummaryGenerationEventHandler
  - [x] ThumbnailProcessingEventHandler
- [x] 5.3 이벤트 저장소 설계 (선택사항)
- [x] 5.4 이벤트 재시도 및 실패 처리 전략

### 6단계: 데이터 모델 및 영속성 설계
- [x] 6.1 PostgreSQL 테이블 설계
  - [x] cards 테이블 (기본 키, 외래 키, 인덱스)
  - [x] 쿼리 패턴별 인덱스 설계
    - [x] created_at 인덱스 (커서 기반 페이지네이션용)
    - [x] user_id + created_at 복합 인덱스
    - [x] category_id + created_at 복합 인덱스
- [x] 6.2 데이터 매핑 전략
  - [x] 도메인 객체 ↔ PostgreSQL 레코드 매핑
  - [x] 복합 값 객체 JSON 컬럼 활용
- [x] 6.3 트랜잭션 및 일관성 전략

### 7단계: 외부 서비스 통합 설계
- [x] 7.1 YouTube API 통합
  - [x] API 키 관리 및 요청 제한 처리
  - [x] 메타데이터 추출 로직
  - [x] 오류 처리 및 재시도 전략
- [x] 7.2 AWS Bedrock Claude 통합
  - [x] 프롬프트 엔지니어링
  - [x] 토큰 제한 및 비용 최적화
  - [x] 비동기 처리 및 콜백 메커니즘
- [x] 7.3 S3 썸네일 저장소 통합
  - [x] 이미지 업로드/다운로드 로직
  - [x] CDN 연동 고려사항

### 8단계: 보안 및 검증 설계
- [x] 8.1 입력 검증 및 데이터 검증
  - [x] YouTube URL 형식 검증
  - [x] 사용자 권한 검증
- [x] 8.2 보안 헤더 및 CORS 설정
- [x] 8.3 API 레이트 리미팅
- [x] 8.4 민감 정보 보호 (API 키, 토큰 등)

### 9단계: 모니터링 및 로깅 설계
- [x] 9.1 구조화된 로깅 설계
  - [x] 요청 추적 ID
  - [x] 비즈니스 이벤트 로깅
- [x] 9.2 메트릭 수집 설계
  - [x] 성능 메트릭
  - [x] 비즈니스 메트릭
- [x] 9.3 알림 및 경고 설계
- [x] 9.4 헬스체크 엔드포인트 설계

### 10단계: 테스트 전략 설계
- [x] 10.1 단위 테스트 전략
  - [x] 도메인 로직 테스트
  - [x] 유스케이스 테스트
- [x] 10.2 통합 테스트 전략
  - [x] 외부 서비스 모킹
  - [x] PostgreSQL 테스트 데이터베이스
- [x] 10.3 API 테스트 전략
- [x] 10.4 성능 테스트 고려사항

### 11단계: 시퀀스 다이어그램 작성
- [x] 11.1 카드 생성 플로우 시퀀스 다이어그램
- [x] 11.2 메타데이터 수집 시퀀스 다이어그램
- [x] 11.3 AI 요약 생성 시퀀스 다이어그램
- [x] 11.4 카드 조회/수정/삭제 시퀀스 다이어그램
- [x] 11.5 오류 처리 시퀀스 다이어그램

### 12단계: 문서화 및 검토
- [x] 12.1 logical_design.md 파일 작성
- [x] 12.2 sequence_diagrams.md 파일 작성
- [x] 12.3 다른 Unit과의 일관성 검토
- [x] 12.4 설계 검증 및 최종 검토

## 설계 시 고려사항

### 성능 최적화
[Question] 카드 목록 조회 시 페이지네이션 방식은 어떻게 하시겠습니까? (오프셋 기반 vs 커서 기반)
[Answer] 커서 기반 페이지네이션 사용

**결정 이유:**
- 무한 스크롤 UI 방식으로 설계 예정
- 카드 개수가 많아질 수 있어 대용량 데이터 처리 성능 중요
- 실시간 카드 추가 시 데이터 중복/누락 방지 필요
- created_at 필드를 커서로 사용하여 일관된 성능 보장

[Question] 썸네일 이미지 캐싱 전략은 어떻게 하시겠습니까? (CDN, 브라우저 캐시 등)
[Answer] CDN + 브라우저 캐싱 (Redis 제외)

**결정 이유:**
- **비용 효율성**: Redis 메모리 비용 절약, CloudFront는 사용량 기반으로 저렴
- **충분한 성능**: CDN 엣지 캐싱 + 브라우저 캐싱으로 빠른 응답 보장
- **단순한 구조**: 별도 캐시 인프라 관리 불필요
- **환경변수 기반**: THUMBNAIL_SOURCE로 YouTube 직접 링크 vs S3+CDN 선택 가능
- **하이브리드 백업**: YouTube 링크 기본 + S3 백업으로 안정성 확보

### 확장성 고려사항
[Question] 향후 다른 동영상 플랫폼(Vimeo, Twitch 등) 지원 확장 가능성을 고려해야 하나요?
[Answer] 다른 동영상 플랫폼은 고려하지 않지만, Instagram 릴스/스토리, Threads, 일반 웹 링크 지원 확장 고려

**확장 고려사항:**
- **Instagram 릴스/스토리**: 메타데이터 제한적, 썸네일만 추출 가능
- **Threads 링크**: 텍스트 기반, 스크립트 없음
- **일반 웹 링크**: 메타 태그 기반 정보 추출, 스크립트 없음
- **공통 특징**: API 요약할 내용이 없는 경우 사용자 메모만 활용
- **아키텍처 고려**: URL 타입별 다른 메타데이터 추출 전략 필요

[Question] AI 요약 외에 다른 AI 기능(태그 자동 생성, 감정 분석 등) 확장 가능성을 고려해야 하나요?
[Answer] 현재는 AI 요약만 구현하되, 확장 가능한 구조로 설계

**AI 기능 확장 고려사항:**
- **태그 자동 생성**: 스크립트/제목 기반 키워드 추출
- **감정 분석**: 콘텐츠 톤 분석 (긍정/부정/중립)
- **카테고리 자동 분류**: 콘텐츠 내용 기반 카테고리 추천
- **아키텍처 고려**: AI 서비스 인터페이스를 추상화하여 다양한 AI 기능 플러그인 방식으로 확장 가능하게 설계

### 운영 고려사항
[Question] 배포 전략은 어떻게 하시겠습니까? (블루-그린, 카나리, 롤링 등)
[Answer] 개발/스테이징은 롤링 배포, 프로덕션은 블루-그린 배포

**결정 이유:**
- **개발/스테이징 - 롤링 배포**: 비용 절약, 구현 단순함, 빈번한 배포에 적합
- **프로덕션 - 블루-그린 배포**: 카드 생성은 핵심 기능으로 무중단 배포 필요, 즉시 롤백 가능
- **AWS ECS/Fargate 활용**: 블루-그린 배포 구현 용이
- **데이터베이스 마이그레이션**: 별도 관리로 배포와 분리
- **환경별 차별화**: 각 환경의 요구사항에 맞는 최적 전략 적용

[Question] 로그 보관 정책은 어떻게 하시겠습니까? (보관 기간, 로그 레벨 등)
[Answer] 3개월 보관, 환경변수로 변경 가능한 구조

**로그 보관 정책:**
- **애플리케이션 로그**: 3개월 보관 (INFO 레벨 이상)
- **보안 로그**: 3년 보관 (인증/인가 실패, 비정상 접근)
- **시스템 로그**: 1개월 보관 (인프라 상태, 성능 지표)

**3개월 선택 이유:**
- 법적 의무 없음 (일반 애플리케이션 로그, 개인식별정보 미포함)
- 충분한 디버깅 기간 (대부분 이슈는 1-2주 내 발견)
- 운영상 여유 확보 (사용자 문의 대응, 성능 분석)
- 비용 효율성 (1개월보다 안전하면서도 과도하지 않음)

**변경 가능한 구조:**
- 환경변수: `LOG_RETENTION_DAYS=90` (기본값)
- 로그 타입별 개별 설정 가능
- AWS CloudWatch 로그 그룹별 보관 정책 설정

## 참고 자료
- Unit3 도메인 모델: `/aidlc-docs/construction/unit3_card_creation/domain_model.md`
- Unit1 논리적 설계: `/aidlc-docs/construction/unit1_authentication/logical_design.md`
- Unit2 논리적 설계: `/aidlc-docs/construction/unit2_category_management/logical_design.md`
- Integration Contract: `/aidlc-docs/inception/units/integration_contract.md`

## 완료 기준
- 모든 아키텍처 레이어가 명확히 정의됨
- 이벤트 기반 아키텍처가 설계됨
- 외부 서비스 통합 방안이 구체적으로 설계됨
- PostgreSQL 데이터 모델이 최적화됨
- API별 시퀀스 다이어그램이 작성됨
- 보안, 성능, 확장성이 고려된 설계가 완성됨
