# Unit5: Card Sharing - 도메인 모델 설계 계획

## 개요
Unit5는 카드를 다른 사용자와 공유하고 공유받은 카드를 처리하는 기능을 담당하는 독립적인 단위입니다. 도메인 주도 설계(DDD)를 사용하여 전술적 구성 요소들을 설계합니다.

## 설계 계획

### 1단계: 도메인 분석 및 이해
- [x] 1.1 사용자 스토리 분석 (US-011, US-012)
- [x] 1.2 핵심 비즈니스 규칙 식별
- [x] 1.3 도메인 전문가 언어(Ubiquitous Language) 정의
- [x] 1.4 도메인 경계 및 컨텍스트 매핑

### 2단계: 애그리게이트 설계
- [x] 2.1 애그리게이트 식별 및 경계 정의
- [x] 2.2 애그리게이트 루트 선정
- [x] 2.3 불변성 규칙 정의
- [x] 2.4 애그리게이트 간 참조 관계 설계

### 3단계: 엔티티 및 값 객체 설계
- [x] 3.1 엔티티 식별 및 속성 정의
- [x] 3.2 값 객체 식별 및 설계
- [x] 3.3 식별자 전략 수립
- [x] 3.4 생명주기 관리 규칙 정의

### 4단계: 도메인 서비스 설계
- [x] 4.1 도메인 서비스 필요성 분석
- [x] 4.2 도메인 서비스 인터페이스 정의
- [x] 4.3 외부 시스템 연동 포인트 식별

### 5단계: 도메인 이벤트 설계
- [x] 5.1 도메인 이벤트 식별
- [x] 5.2 이벤트 페이로드 설계
- [x] 5.3 이벤트 발행 시점 정의
- [x] 5.4 이벤트 처리 정책 수립

### 6단계: 리포지토리 설계
- [x] 6.1 리포지토리 인터페이스 정의
- [x] 6.2 조회 메서드 설계
- [x] 6.3 영속성 전략 수립

### 7단계: 정책 및 명세 설계
- [x] 7.1 비즈니스 정책 식별
- [x] 7.2 명세 패턴 적용
- [x] 7.3 유효성 검증 규칙 정의

### 8단계: 통합 및 검증
- [x] 8.1 다른 Unit과의 통합 포인트 확인
- [x] 8.2 Integration Contract 업데이트 필요성 검토
- [x] 8.3 오류 코드 추가 필요성 검토
- [x] 8.4 설계 일관성 검증

## 주요 고려사항

### 비즈니스 규칙
- 공유 링크는 7일간 유효
- 공유 링크는 인증 없이 접근 가능
- 로그인된 회원이 공유 링크 접근 시 "공유받은 카드" 카테고리에 자동 저장
- 중복 저장 방지
- 공유 카드는 원본과 독립적인 복사본으로 저장

### 기술적 고려사항
- 공유 링크 생성 전략 (UUID vs 단축 URL)
- 만료 처리 메커니즘
- 중복 저장 방지 로직
- 익명 사용자와 인증된 사용자 구분 처리

[Question] 공유 링크 생성 시 단축 URL 형태를 원하시나요, 아니면 UUID 기반의 긴 링크를 사용하시겠습니까?
[Answer] UUID 기반의 긴 링크 사용
**이유**: 구현 단순성과 안정성 우선. 충돌 처리 로직이 불필요하고 추가 인프라 없이도 안정적으로 동작

[Question] 공유 링크의 만료 처리는 어떻게 하시겠습니까? (예: 배치 작업으로 주기적 삭제, 접근 시점에 검증, 소프트 삭제 등)
[Answer] 접근 시점에 검증 (created_at + 7일 비교)
**이유**: 실시간 정확성과 단순성의 균형. 추가 배치 작업이나 인프라 복잡성 없이 정확한 만료 처리 가능

[Question] 동일한 카드를 여러 번 공유할 때 새로운 링크를 생성하시겠습니까, 아니면 기존 링크를 재사용하시겠습니까?
[Answer] 새로운 링크를 생성
**이유**: 각 공유 세션의 독립성과 구현 단순성. 복잡한 조회 로직이나 동시성 처리 없이도 안정적 동작

[Question] 공유 카드 저장 시 중복 확인은 어떤 기준으로 하시겠습니까? (예: YouTube URL 기준, 카드 제목 기준 등)
[Answer] YouTube URL 기준
**이유**: 기존 Unit3 로직과 일관성 유지. 정확한 중복 판별이 가능하고 구현이 단순함 

## 예상 결과물
- domain_model.md: 완전한 도메인 모델 설계 문서
- integration_contract.md 업데이트 (필요시)
- 오류 코드 추가 (필요시)

---

## 논리적 설계 생성 계획

### 9단계: 아키텍처 패턴 선정
- [x] 9.1 헥사고날 아키텍처 적용 계획 수립
- [x] 9.2 포트와 어댑터 식별 및 정의
- [x] 9.3 의존성 역전 원칙 적용 방안 설계
- [x] 9.4 계층별 책임 분리 전략 수립

### 10단계: 애플리케이션 서비스 설계
- [x] 10.1 애플리케이션 서비스 식별 및 정의
- [x] 10.2 유스케이스별 서비스 메서드 설계
- [x] 10.3 트랜잭션 경계 및 일관성 정책 수립
- [x] 10.4 오류 처리 및 예외 전략 설계

### 11단계: 인프라스트럭처 설계
- [x] 11.1 데이터베이스 스키마 상세 설계
- [x] 11.2 리포지토리 구현 전략 수립
- [x] 11.3 외부 시스템 연동 어댑터 설계
- [x] 11.4 이벤트 발행/구독 메커니즘 설계

### 12단계: API 인터페이스 설계
- [x] 12.1 REST API 엔드포인트 상세 설계
- [x] 12.2 요청/응답 DTO 설계
- [x] 12.3 HTTP 상태 코드 및 오류 응답 정의
- [x] 12.4 Open Graph 메타데이터 응답 설계

### 13단계: 보안 및 성능 설계
- [x] 13.1 인증/인가 처리 방안 설계
- [x] 13.2 공유 링크 보안 전략 수립
- [x] 13.3 캐싱 전략 및 성능 최적화 방안
- [x] 13.4 레이트 리미팅 및 남용 방지 설계

### 14단계: 통합 및 배포 설계
- [x] 14.1 다른 Unit과의 통합 인터페이스 설계
- [x] 14.2 이벤트 기반 통신 설계
- [x] 14.3 배포 및 운영 고려사항 정리
- [x] 14.4 모니터링 및 로깅 전략 수립

### 15단계: 시퀀스 다이어그램 생성
- [x] 15.1 공유 링크 생성 시퀀스 다이어그램
- [x] 15.2 공유 카드 조회 시퀀스 다이어그램 (익명 사용자)
- [x] 15.3 공유 카드 조회 시퀀스 다이어그램 (인증된 사용자)
- [x] 15.4 공유 카드 자동 저장 시퀀스 다이어그램
- [x] 15.5 Open Graph 메타데이터 제공 시퀀스 다이어그램

### 16단계: 문서화 및 검증
- [x] 16.1 logical_design.md 문서 작성
- [x] 16.2 sequence_diagrams.md 문서 작성
- [x] 16.3 설계 일관성 검증
- [x] 16.4 다른 Unit과의 호환성 확인

## 주요 고려사항 (논리적 설계)

### 아키텍처 고려사항
- **헥사고날 아키텍처**: 도메인 로직과 인프라 분리
- **이벤트 기반**: 다른 Unit과의 느슨한 결합
- **CQRS 패턴**: 조회와 명령 분리 (공유 링크 조회 최적화)
- **캐싱 전략**: Redis 활용한 공유 링크 캐싱

### 성능 고려사항
- **공유 링크 조회 최적화**: 가장 빈번한 작업
- **메타데이터 캐싱**: Open Graph 태그 생성 최적화
- **배치 정리**: 만료된 링크 정리 작업
- **CDN 활용**: 썸네일 이미지 캐싱

### 보안 고려사항
- **토큰 보안**: UUID 기반 예측 불가능한 링크
- **접근 제어**: 만료 시간 엄격한 검증
- **남용 방지**: 공유 링크 생성 레이트 리미팅
- **개인정보 보호**: 익명 접근 시 최소 정보만 노출

[Question] 공유 링크 조회 성능 최적화를 위해 Redis 캐싱을 사용하시겠습니까?
[Answer] Redis 캐싱 사용
**이유**: 공유 링크 조회는 가장 빈번한 작업(메신저 크롤러, 사용자 접근)이므로 성능 최적화 필수. Redis TTL로 만료 시간 자동 처리 가능하여 구현도 단순해짐. DB 부하 감소로 전체 시스템 안정성 향상.

[Question] 메신저 크롤러의 Open Graph 메타데이터 요청을 별도 엔드포인트로 분리하시겠습니까, 아니면 일반 조회 API에서 User-Agent로 구분하시겠습니까?
[Answer] User-Agent로 구분하여 동일 엔드포인트 사용
**이유**: 단일 URL로 일반 사용자(JSON)와 크롤러(HTML+메타태그) 모두 처리. 메신저에서 링크 공유 시 자동 미리보기 생성. API 엔드포인트 단순화 및 통합 캐싱으로 효율성 향상. 카카오톡, 텔레그램 등 크롤러별 User-Agent 패턴 활용.

[Question] 공유 링크 생성 시 레이트 리미팅을 적용하시겠습니까? (예: 사용자당 시간당 10개 제한)
[Answer] 사용자당 시간당 20개 제한 적용
**이유**: 남용 방지(스팸, 자동화 도구) 및 서버 리소스 보호. 20개는 정상 사용자에게 충분한 여유를 제공하면서도 남용을 효과적으로 차단. Redis 기반 슬라이딩 윈도우 방식으로 구현하여 정확한 제어 가능.

[Question] 만료된 공유 링크 정리를 위한 배치 작업 주기는 어떻게 설정하시겠습니까?
[Answer] 매일 새벽 2시 1회 실행 (2단계 삭제 정책)
**이유**: 
- **1단계 (소프트 삭제)**: 만료 즉시 deleted_at 설정, 기본 메타데이터는 계속 제공
- **2단계 (물리 삭제)**: 30일 후 완전 삭제
- 메신저 썸네일 지속성 보장 (카카오톡 등에서 기본 앱 정보 표시)
- 사용자 경험 향상 (공유된 링크가 갑자기 사라지지 않음)
- 트래픽 적은 시간대 실행으로 성능 영향 최소화 

## 예상 결과물 (논리적 설계)
- logical_design.md: 완전한 논리적 설계 문서
- sequence_diagrams.md: API별 시퀀스 다이어그램
- 아키텍처 다이어그램 (Mermaid 형식)
- 데이터베이스 스키마 상세 설계
