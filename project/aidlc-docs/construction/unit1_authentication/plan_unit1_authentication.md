# Unit1 Authentication & Profile Management - Domain Model Design Plan

## 개요
Unit1의 도메인 주도 설계(DDD) 도메인 모델을 설계하기 위한 단계별 계획입니다.

## 계획 단계

### 1. 도메인 분석 및 이해
- [x] 1.1 사용자 스토리 분석 및 핵심 비즈니스 규칙 식별
- [x] 1.2 도메인 전문가 언어(Ubiquitous Language) 정의
- [x] 1.3 바운디드 컨텍스트(Bounded Context) 경계 확인

### 2. 애그리게이트 식별 및 설계
- [x] 2.1 핵심 엔티티 식별 (User, Session, Profile 등)
- [x] 2.2 애그리게이트 루트 결정
- [x] 2.3 애그리게이트 경계 정의
- [x] 2.4 애그리게이트 간 관계 설계

[Question] 사용자 인증에서 이메일 인증 코드의 유효 시간은 얼마나 되나요?
[Answer] 15분

[Question] 세션 관리에서 동시 로그인 제한이 있나요? (예: 한 계정당 최대 몇 개의 디바이스에서 로그인 가능)
[Answer] 3개, 3개 이상 로그인 시 유효기간이 짧게 남은 기존 세션 종료

[Question] 회원 탈퇴 시 데이터 보관 정책이 있나요? (즉시 삭제 vs 일정 기간 보관 후 삭제)
[Answer] 1년

### 3. 엔티티 및 값 객체 설계
- [x] 3.1 User 엔티티 설계 (식별자, 속성, 행동)
- [x] 3.2 Profile 엔티티 설계
- [x] 3.3 Session 엔티티 설계
- [x] 3.4 값 객체 식별 및 설계 (Email, VerificationCode, Gender, BirthYear 등)
- [x] 3.5 엔티티 간 연관관계 정의

### 4. 도메인 이벤트 설계
- [x] 4.1 사용자 등록 관련 이벤트 (UserRegistered, EmailVerificationRequested 등)
- [x] 4.2 인증 관련 이벤트 (UserLoggedIn, UserLoggedOut, SessionExpired 등)
- [x] 4.3 프로필 관리 이벤트 (ProfileUpdated, UserDeactivated 등)
- [x] 4.4 이벤트 발행 시점 및 처리 방식 정의

### 5. 도메인 서비스 설계
- [x] 5.1 인증 서비스 (AuthenticationService)
- [x] 5.2 이메일 인증 서비스 (EmailVerificationService)
- [x] 5.3 세션 관리 서비스 (SessionManagementService)
- [x] 5.4 사용자 등록 서비스 (UserRegistrationService)

### 6. 정책(Policy) 설계
- [x] 6.1 비밀번호 정책 (이메일 인증 코드 관련)
- [x] 6.2 세션 만료 정책
- [x] 6.3 중복 가입 방지 정책
- [x] 6.4 계정 비활성화 정책

### 7. 리포지토리 인터페이스 설계
- [x] 7.1 UserRepository 인터페이스 정의
- [x] 7.2 SessionRepository 인터페이스 정의
- [x] 7.3 VerificationCodeRepository 인터페이스 정의
- [x] 7.4 리포지토리 메서드 시그니처 정의

### 8. 애플리케이션 서비스 인터페이스 설계
- [x] 8.1 사용자 등록 유스케이스 인터페이스
- [x] 8.2 로그인/로그아웃 유스케이스 인터페이스
- [x] 8.3 프로필 관리 유스케이스 인터페이스
- [x] 8.4 세션 관리 유스케이스 인터페이스

### 9. 도메인 모델 문서화
- [x] 9.1 애그리게이트 다이어그램 작성
- [x] 9.2 도메인 이벤트 플로우 다이어그램 작성
- [x] 9.3 각 컴포넌트별 상세 설명 작성
- [x] 9.4 비즈니스 규칙 및 제약사항 문서화

### 10. 검토 및 검증
- [x] 10.1 사용자 스토리와 도메인 모델 매핑 검증
- [x] 10.2 도메인 전문가와 모델 검토
- [x] 10.3 다른 바운디드 컨텍스트와의 통합 지점 확인
- [x] 10.4 최종 도메인 모델 승인

## 산출물
- `domain_model.md`: 완성된 도메인 모델 문서
- 애그리게이트 다이어그램
- 도메인 이벤트 플로우 다이어그램

## 참고사항
- 코드 스니펫은 생성하지 않고 개념적 설계에 집중
- DDD 전술적 패턴을 모두 활용하여 완전한 도메인 모델 구성
- 사용자 스토리의 인수 기준을 모두 만족하는 설계 보장

---

# Unit1 Authentication & Profile Management - Logical Design Plan

## 개요
Unit1의 도메인 모델을 기반으로 소프트웨어 소스 코드 구현을 위한 논리적 설계를 생성하는 단계별 계획입니다.

## 논리적 설계 계획 단계

### 1. 아키텍처 레이어 설계
- [x] 1.1 헥사고날 아키텍처 레이어 구조 정의
- [x] 1.2 도메인 레이어 패키지 구조 설계
- [x] 1.3 애플리케이션 레이어 패키지 구조 설계
- [x] 1.4 인프라스트럭처 레이어 패키지 구조 설계
- [x] 1.5 인터페이스 레이어 패키지 구조 설계

### 2. 도메인 레이어 논리적 설계
- [x] 2.1 애그리게이트 클래스 구조 설계
- [x] 2.2 엔티티 클래스 구조 및 메서드 시그니처 설계
- [x] 2.3 값 객체 클래스 구조 및 검증 로직 설계
- [x] 2.4 도메인 이벤트 클래스 구조 설계
- [x] 2.5 도메인 서비스 인터페이스 및 구현 설계
- [x] 2.6 정책 클래스 구조 및 검증 로직 설계
- [x] 2.7 도메인 예외 클래스 계층 구조 설계

### 3. 애플리케이션 레이어 논리적 설계
- [x] 3.1 애플리케이션 서비스 클래스 구조 설계
- [x] 3.2 커맨드/쿼리 객체 설계 (CQRS 패턴)
- [x] 3.3 DTO (Data Transfer Object) 설계
- [x] 3.4 애플리케이션 이벤트 핸들러 설계
- [x] 3.5 트랜잭션 경계 및 관리 전략 설계
- [x] 3.6 보안 및 권한 검증 로직 설계

### 4. 인프라스트럭처 레이어 논리적 설계
- [x] 4.1 PostgreSQL 리포지토리 구현 설계
- [x] 4.2 PostgreSQL 테이블 설계 및 인덱스 전략
- [x] 4.3 AWS SES 이메일 서비스 어댑터 설계
- [x] 4.4 이벤트 스토어 구현 설계
- [x] 4.5 Redis 캐싱 전략 및 구현 설계
- [x] 4.6 외부 서비스 통합 어댑터 설계

[Question] PostgreSQL 테이블 설계에서 인덱스 전략은 어떻게 하시겠습니까? 이메일 조회, 세션 조회 등을 위한 인덱스가 필요합니다.
[Answer] 사용자 시나리오 기반 인덱스 전략: 1) Users 테이블 - UNIQUE INDEX on email (가장 빈번한 조회), INDEX on status, 2) Sessions 테이블 - INDEX on (user_id, is_active) for 동시 로그인 제한 체크, INDEX on expires_at for 만료 세션 정리, 3) Verification_Codes 테이블 - INDEX on (email, purpose, is_used) for 인증 코드 검증, 4) 부분 인덱스 활용 (WHERE is_active = true, WHERE is_used = false)로 공간 절약 및 성능 최적화

[Question] 이메일 발송 서비스는 AWS SES를 사용하시겠습니까?
[Answer] 예, AWS SES 사용

### 5. 인터페이스 레이어 논리적 설계
- [x] 5.1 FastAPI 컨트롤러 설계
- [x] 5.2 요청/응답 Pydantic 모델 설계
- [x] 5.3 API 문서화 구조 설계 (OpenAPI/Swagger)
- [x] 5.4 JWT 인증/인가 미들웨어 설계
- [x] 5.5 예외 처리 및 오류 응답 설계
- [x] 5.6 API 버전 관리 전략 설계

### 6. 데이터 모델링 및 영속성 설계
- [x] 6.1 PostgreSQL 테이블 스키마 설계
- [x] 6.2 SQLAlchemy ORM 모델 설계
- [x] 6.3 데이터 일관성 및 트랜잭션 전략 설계
- [x] 6.4 데이터 마이그레이션 전략 설계 (Alembic)
- [x] 6.5 백업 및 복구 전략 설계

[Question] PostgreSQL에서 User-Profile 관계를 어떻게 모델링하시겠습니까? 별도 테이블로 분리하되 강한 일관성을 보장하는 방향으로 하시겠습니까?
[Answer] 별도 테이블 분리 + 강한 일관성 전략: 1) Users 테이블(핵심 인증 정보), Profiles 테이블(개인정보) 분리, 2) 외래키 제약조건 + UNIQUE INDEX로 1:1 관계 보장, 3) 트랜잭션으로 User-Profile 동시 생성, 4) 필요 시에만 JOIN 조회로 성능 최적화, 5) 도메인 모델에서는 User 애그리게이트가 Profile 포함하되 물리적으로는 별도 테이블 

### 7. 보안 및 인증 설계
- [x] 7.1 JWT 토큰 구조 및 클레임 설계
- [x] 7.2 세션 관리 및 토큰 갱신 전략 설계
- [x] 7.3 비밀번호 없는 인증 플로우 설계
- [x] 7.4 API 보안 헤더 및 CORS 설정 설계
- [x] 7.5 레이트 리미팅 및 DDoS 방어 설계
- [x] 7.6 감사 로깅 및 보안 모니터링 설계

### 8. 이벤트 기반 아키텍처 설계
- [x] 8.1 도메인 이벤트 발행 메커니즘 설계
- [x] 8.2 이벤트 스토어 스키마 설계
- [x] 8.3 이벤트 핸들러 등록 및 디스패치 설계
- [x] 8.4 비동기 이벤트 처리 설계 (Celery/Redis)
- [x] 8.5 이벤트 재시도 및 실패 처리 설계
- [x] 8.6 이벤트 버전 관리 및 스키마 진화 설계

### 9. 성능 및 확장성 설계
- [x] 9.1 Redis 캐싱 레이어 설계
- [x] 9.2 PostgreSQL 쿼리 최적화 전략
- [x] 9.3 API 응답 시간 최적화 설계
- [x] 9.4 동시성 제어 및 락 전략 설계
- [x] 9.5 수평 확장 전략 설계
- [x] 9.6 모니터링 및 메트릭 수집 설계

[Question] 캐싱 전략에서 어떤 데이터를 캐시하시겠습니까? 사용자 세션, 프로필 정보, 인증 코드 등 중 우선순위가 있나요?
[Answer] Redis 캐싱 우선순위: 1순위) 사용자 세션 (session:{session_id}, TTL 7일) - 모든 API 요청마다 검증, 2순위) 사용자 기본 정보 (user:{user_id}, TTL 1시간) - 상태 및 언어 설정, 3순위) 인증 코드 (verification:{email}:{purpose}, TTL 15분) - 빠른 검증, 민감한 개인정보는 캐싱 제외 

### 10. 테스트 전략 설계
- [x] 10.1 pytest 기반 단위 테스트 구조 설계
- [x] 10.2 통합 테스트 시나리오 설계
- [x] 10.3 FastAPI TestClient 기반 API 테스트 설계
- [x] 10.4 성능 테스트 시나리오 설계
- [x] 10.5 보안 테스트 계획 설계
- [x] 10.6 테스트 데이터 관리 전략 설계

### 11. 배포 및 운영 설계
- [x] 11.1 AWS 인프라 아키텍처 설계 (RDS, ElastiCache, ECS)
- [x] 11.2 CI/CD 파이프라인 설계 (GitHub Actions)
- [x] 11.3 환경별 설정 관리 설계 (Pydantic Settings)
- [x] 11.4 로깅 및 모니터링 시스템 설계 (CloudWatch)
- [x] 11.5 알림 및 장애 대응 프로세스 설계
- [x] 11.6 백업 및 재해 복구 계획 설계

### 12. 문서화 및 검토
- [x] 12.1 FastAPI 자동 API 문서 생성 설계
- [x] 12.2 아키텍처 결정 기록(ADR) 작성
- [x] 12.3 코드 리뷰 가이드라인 작성
- [x] 12.4 운영 가이드 작성
- [x] 12.5 논리적 설계 검토 및 승인
- [x] 12.6 구현 가이드라인 작성

## 산출물
- `logical_design.md`: 완성된 논리적 설계 문서
- 클래스 다이어그램 및 시퀀스 다이어그램
- API 명세서 (OpenAPI 스펙)
- PostgreSQL 스키마 설계서
- 아키텍처 결정 기록 (ADR)

## 참고사항
- 도메인 모델을 기반으로 구현 가능한 구체적 설계 작성
- FastAPI + PostgreSQL + AWS 서비스 활용 최적화
- 확장성과 유지보수성을 고려한 설계
- 보안 및 성능 요구사항 충족


